{"./":{"url":"./","title":"前言","keywords":"","body":"HTTP后台端：RESTful API接口设计 最新版本：v2.4 更新时间：20180619 简介 整理过HTTP知识总结后，继续去整理HTTP的后台相关的技术。 在服务器后台进行设计API接口时，目前最流行的风格（原则/标准/规范）就是RESTful。 源码+浏览+下载 本书的各种源码、在线浏览地址、多种格式文件下载如下： Gitook源码 crifan/http_restful_api: HTTP后台端：RESTful API接口设计 如何使用此Gitbook源码去生成发布为电子书 详见：crifan/gitbook_template: 演示如何使用crifan的gitbook的模板去创建自己的gitbook电子书 在线浏览 HTTP后台端：RESTful API接口设计 book.crifan.com HTTP后台端：RESTful API接口设计 crifan.github.io 离线下载阅读 HTTP后台端：RESTful API接口设计 PDF HTTP后台端：RESTful API接口设计 ePub HTTP后台端：RESTful API接口设计 Mobi crifan.com，使用知识署名-相同方式共享4.0协议发布 all right reserved，powered by Gitbook该文件修订时间： 2018-06-19 22:59:04 "},"restful_intro/":{"url":"restful_intro/","title":"RESTful API简介","keywords":"","body":"RESTful API简介 服务器后台设计API接口时，目前最流行的风格（原则/标准/规范）就是RESTful。 其中 REST=REpresentational State Transfer REST直译：表现层状态转移 REST核心含义：无状态的资源 资源的变化（CURD）都是通过操作去实现的 资源可以用 URI 表示 用不同的URI和方法，表示对资源的不同操作 典型的： GET：获取资源 POST：新建资源 DELETE：删除资源 RESTful的通俗理解 借用某人的总结： 看url就知道要什么 看http method就知道干什么 看http status code就知道结果如何 其他类型的接口设计风格(含RESTful) ROA=Resource Oriented Architecture RPC=Remote Procedure Call SOA=Simple Object Access Protocol REST=REpresentational State Transfer 关于无状态的解释 有状态 无状态 crifan.com，使用知识署名-相同方式共享4.0协议发布 all right reserved，powered by Gitbook该文件修订时间： 2017-12-20 10:29:52 "},"restful_intro/example.html":{"url":"restful_intro/example.html","title":"举例","keywords":"","body":"RESTful API常见形式举例 下面找些常见的RESTful的API供参考和有个直观的概念： RESTful的订单的API ========== ===================== ================================== HTTP 方法 行为 示例 ========== ===================== ================================== GET 获取资源的信息 http://example.com/api/orders GET 获取某个特定资源的信息 http://example.com/api/orders/123 POST 创建新资源 http://example.com/api/orders PUT 更新资源 http://example.com/api/orders/123 DELETE 删除资源 http://example.com/api/orders/123 ========== ====================== ================================== RESTful的客户的API POST http://www.example.com/customers POST http://www.example.com/customers/12345/orders GET http://www.example.com/customers/12345 GET http://www.example.com/customers/12345/orders GET http://www.example.com/buckets/sample PUT http://www.example.com/customers/12345 PUT http://www.example.com/customers/12345/orders/98765 PUT http://www.example.com/buckets/secret_stuff DELETE http://www.example.com/customers/12345 DELETE http://www.example.com/customers/12345/orders DELETE http://www.example.com/bucket/sample RESTful的待办事项TodoList的API ========== =============================================== ============= HTTP 方法 URL 动作 ========== =============================================== ============= GET http://[hostname]/todo/api/v1.0/tasks 检索任务列表 GET http://[hostname]/todo/api/v1.0/tasks/[task_id] 检索某个任务 POST http://[hostname]/todo/api/v1.0/tasks 创建新任务 PUT http://[hostname]/todo/api/v1.0/tasks/[task_id] 更新任务 DELETE http://[hostname]/todo/api/v1.0/tasks/[task_id] 删除任务 ========== ================================================ ============= 更多细节详见：【整理】TodoList待办事项：常被用于解释一个概念和框架如何应用） crifan.com，使用知识署名-相同方式共享4.0协议发布 all right reserved，powered by Gitbook该文件修订时间： 2017-12-20 10:29:20 "},"restful_rule/":{"url":"restful_rule/","title":"RESTful API通用设计规则","keywords":"","body":"RESTful API通用设计规则 对于RESTful的API设计，有些通用的设计规则。其实也可以叫做HTTP的各种方法的典型用法。 crifan.com，使用知识署名-相同方式共享4.0协议发布 all right reserved，powered by Gitbook该文件修订时间： 2018-06-19 22:19:01 "},"restful_rule/rule.html":{"url":"restful_rule/rule.html","title":"通用设计规则","keywords":"","body":"通用设计规则 资源：往往对应着后台系统中对象，比如一个用户User，一个待办事项todo item，一个任务Task等等 用对应的接口表示要对资源进行何种操作，想要实现什么目的： HTTP Verb=HTTP方法 操作类型=CRUD 返回值 POST Create创建 正常201 (Created)异常404 (Not Found)409 (Conflict) GET Read读取 正常：200 (OK)异常：404 (Not Found) PUT Replace替换 正常：200 (OK)异常405 (Method Not Allowed)204 (No Content)404 (Not Found) PATCH Update/Modify更新 正常：200 (OK)异常405 (Method Not Allowed)204 (No Content)404 (Not Found) DELETE Delete删除 正常：200 (OK)204 (No Content)异常：404 (Not Found)405 (Method Not Allowed) 举例：RESTful的某个类似于外卖的项目的API 此处给出之前做过一个项目的RESTful的API，供参考： 用户 获取用户ID：支持多个参数，根据参数不同返回对应的值 GET /v1.0/open/userId?type=phone&phone={phone} GET /v1.0/open/userId?type=email&email={email} GET /v1.0/open/userId?type=facebook&facebookUserId={facebookUserId} 获取用户信息 GET /v1.0/users/{userId} 修改用户信息 PUT /v1.0/users/{userId}/info 修改密码 PUT /v1.0/users/{userId}/password 订单 获取订单任务信息 GET /v1.0/tasks/{taskId}/users/{userId} 发布任务 POST /v1.0/tasks/users/{userId} 发单人确认任务信息 PUT /v1.0/tasks/{taskId}/users/{userId}/confirmInfo 常见问题 在具体设计接口时，会遇到一些具体的某些接口，到底应该用哪个HTTP的方法等方面的问题，整理如下供参考： 更新资源到底应该用PATCH还是PUT? 对于更新一个资源，很多人都会遇到这个问题，到底应该用PATCH还是PUT？ 现解释如下： HTTP的官方规范定义中，其实是： HTTP方法 主要目的 传入参数 额外说明或注意事项 PUT 把某个资源的整体的信息替换掉 该资源的 全部 的字段 换言之：当某些字段没有传的话，则直接设置为null PATCH 把某个资源的部分信息更新掉 该资源的（你想要更新数据的那）部分的字段 PATCH是在PUT之后才提出来，进入官方规范的。目的就是，只更新你传了值的那些字段，保留其他字段的已有的值 warning:: 最佳实践==大家的实际做法 只不过，现在大家的常见的，实际的做法往往是： 用PUT实现了PATCH的效果： 使用PUT，但只传递部分字段，然后更新相应的字段 举例说明 有一个user用户，信息是： { \"name\": \"zhangsan\", \"email\": \"xxx@x.com\" } 按照PUT的规范来说，如果想要更新这个用户的邮箱，则需要传递： PUT /user/some_user_id { \"name\": \"zhangsan\", \"email\": \"yyy@y.com\" } 否则如果传递： PUT /user/some_user_id { \"email\": \"yyy@y.com\" } REST标准中PUT就会认为，你没有其他字段，包括name，则会去设置name为null -> 这样才是原本想要的replace替换的效果 而如果只是想要更新用户邮箱，应该去用PATCH，传递： PATCH /user/some_user_id { \"email\": \"yyy@y.com\" } 然后才可以实现：只更新email字段，保留其他字段的已有的值 但是现在实际上大部人都是为了省事，也可以说作为最佳实践，用PUT代替PATCH，传入 PUT /user/some_user_id { \"email\": \"yyy@y.com\" } 去实现（只）更新email邮箱，而保留其他（比如用户名name）的效果。 POST创建资源成功后是返回200还是201? 虽然按照REST协议来说，POST了新建的，应该返回201 但是为了统一处理，以及：很多开发者未必能很好的处理201，所以： 对于操作成功的，都正常返回200即可。 然后在response中返回对应的信息 比如： 新建的对象的详细信息 或者只是新建对象的id 结论： HTTP协议规范：POST创建成功后，应该返回201，以及对应的新的资源的id 用户再通过新建资源的id，去获取资源详情 最佳实践：大家实际的常见做法则是，直接返回新建资源的所有的详情的json，其中包括id crifan.com，使用知识署名-相同方式共享4.0协议发布 all right reserved，powered by Gitbook该文件修订时间： 2018-06-19 22:34:46 "},"restful_rule/hateoas.html":{"url":"restful_rule/hateoas.html","title":"HATEOAS","keywords":"","body":"HATEOAS HATEOAS = Hypermedia As The Engine Of Application State = 超媒体即应用状态引擎 谈到REST时，往往会提到这个HATEOAS。 什么是HATEOAS？ 或者说： 为何会有HATEOAS？ HATEOAS有什么好处或作用？ 找个例子来比喻，就容易理解了： HATEOAS的例子 比如有个用户的对象，或者说资源，定义是： class Customer { String name; } 而普通的REST，GET后返回的信息是： { \"name\" : \"Alice\" } 而简单点的HATEOAS则返回是： { \"name\": \"Alice\", \"links\": [ { \"rel\": \"self\", \"href\": \"http://localhost:8080/customer/1\" } ] } 好处是： 客户端，不需要再去问提供了接口的服务器端，就可以通过此HATEOAS返回的信息中知道一些额外的信息： rel： 表示relationship关系。此处的self指的是就是对象Customer自己本身。 而更加复杂点的情况中，可能会包含其他的对象，比如\"rel\":\"customer\" href：当前对象的完整的url地址。 由此可以看出： 如果后台接口支持，或者说实现了HATEOAS这套标准（规范），那么： 调用接口的前端（移动端等），就可以像： 用户通过点击页面的href的链接地址，而跳转到其他网页，实现浏览网页的过程了。 -> 让调用REST的api就可以实现，类似于用户浏览网页的从一个页面跳转到另外一个页面的过程了 -> 而这种超链接方式的api用于告诉用户：该资源的只允许哪些操作（比如GET,POST)，以及不允许哪些操作（比如DELETE） -> 从而达到方便用户更加清楚使用你的接口的目的 关于HATEOAS的最佳实践：不用HATEOAS 但是HATEOAS的缺点也很明显： 就把简单的返回的信息，搞的更加复杂了。 也因此实际在开发REST的api过程中，至少我是很少采用这个规范的。 当然，也有和我持同样观点的，比如这位 -》这样会让前端解析API时，倒是变得更加复杂了。显得多此一举和增加复杂度了。 而之前自己在折腾选择好的Flask的REST API的框架期间，本来觉得eve不错，后来就是由于发现eve默认使用HATEOAS，把返回的json搞的太复杂，而放弃eve的。 顺带提及一点的是： 针对于HATEOAS标准，也还有是别人会用的。 所以一些流行的REST的框架中，有些也是内置支持了HATEOAS。 比如：Flask的REST框架： eve ripozo flask-marshmallow 另外，再贴出来一个复杂点的HATEOAS的例子，仅供了解： { \"content\": [ { \"price\": 499.00, \"description\": \"Apple tablet device\", \"name\": \"iPad\", \"links\": [ { \"rel\": \"self\", \"href\": \"http://localhost:8080/product/1\" } ], \"attributes\": { \"connector\": \"socket\" } }, { \"price\": 49.00, \"description\": \"Dock for iPhone/iPad\", \"name\": \"Dock\", \"links\": [ { \"rel\": \"self\", \"href\": \"http://localhost:8080/product/3\" } ], \"attributes\": { \"connector\": \"plug\" } } ], \"links\": [ { \"rel\": \"product.search\", \"href\": \"http://localhost:8080/product/search\" } ] } crifan.com，使用知识署名-相同方式共享4.0协议发布 all right reserved，powered by Gitbook该文件修订时间： 2018-06-19 22:24:52 "},"restful_tool/":{"url":"restful_tool/","title":"RESTful API工具和库","keywords":"","body":"RESTful API工具和库 下面介绍和RESTful API开发、设计时相关的一些工具、库。 crifan.com，使用知识署名-相同方式共享4.0协议发布 all right reserved，powered by Gitbook该文件修订时间： 2017-12-14 09:59:54 "},"restful_tool/test_tool.html":{"url":"restful_tool/test_tool.html","title":"开发测试工具","keywords":"","body":"RESTful的API测试工具 Postman 详见另外的教程：API开发利器：Postman PyCharm中的Restful API测试工具 详见：【整理】flask restful api 测试工具 Chrome插件：Advanced REST client 详见：［记录］chrome的websocket插件：Advanced REST client crifan.com，使用知识署名-相同方式共享4.0协议发布 all right reserved，powered by Gitbook该文件修订时间： 2017-12-29 11:15:07 "},"restful_tool/framework_lib.html":{"url":"restful_tool/framework_lib.html","title":"框架和库","keywords":"","body":"Restful的API开发设计工具和框架 Python语言 Flask-RESTful Javascript NodeJS的ExpressJS PHP Slim Ruby Sinatra .NET Nancy - Lightweight Web Framework for .net crifan.com，使用知识署名-相同方式共享4.0协议发布 all right reserved，powered by Gitbook该文件修订时间： 2017-12-30 22:55:05 "},"restful_doc/":{"url":"restful_doc/","title":"RESTful API如何写接口文档","keywords":"","body":"如何写API接口文档 如果你是后台API开发人员，往往会为了写清晰的API接口文档而发愁 此处，自己的建议和经验是： 方法1: 用markdown写API文档 方法2: 用Postman生成API文档 方法3: 用Swagger写（设计API接口的同时就可以生成出）API文档 并可生成对应的后台和前端的代码 剩下只需要编写业务逻辑代码即可 后来发现其他还有一些API文档工具，比如： docute ShowDoc 小幺鸡 接口文档管理工具 也支持API接口调试 下面详细介绍这些写API文档的不同方法。 crifan.com，使用知识署名-相同方式共享4.0协议发布 all right reserved，powered by Gitbook该文件修订时间： 2017-12-29 11:17:31 "},"restful_doc/use_markdown.html":{"url":"restful_doc/use_markdown.html","title":"用Markdown写API文档","keywords":"","body":"用Markdown写API文档 举例： 一个GET方法，用于获取验证码的接口： 在postman中已经调试完毕： 然后去（推荐）有道云笔记中编写markdown： # API接口 ## 注册 ### 获取验证码 目前有4种短信验证码，对应的type是： - 注册短信验证码： register - 修改密码短信验证码: changePassword - 修改手机短信验证码: changePhoneNumber - 验证手机号短信验证码: verifyPhoneNumber #### Request - Method: **GET** - URL: ```/v1.0/open/smscode?type={type}&phone={phone}``` - register for new user: ```/v1.0/open/smscode?type=register&phone=13811119999``` - forgot password: ```/v1.0/open/smscode?type=changePassword&phone=13822224444``` - Headers： - Body: ``` ``` #### Response - Body ``` { \"code\": 200, \"data\": \"730781\", \"message\": \"OK\" } ``` 注意：为了防止短信验证码被滥用，短信如果发送后，需要隔60s才能重新发送。 对应的效果： 另外，再举个有request也有response的POST的例子： ### 创建新用户 #### Reuqest - Method: **POST** - URL: ```/v1.0/open/register``` - Headers： Content-Type:application/json - Body: ``` { \"phone\" : \"13511112222\", \"smsCode\" : \"730781\", \"email\" : \"crifan@webonn.com\", \"firstName\" : \"crifan\", \"lastName\" : \"Li\", \"password\" : \"654321\", \"facebookUserId\" : \"123907074803456\" } ``` #### Response - Body ``` { \"code\": 200, \"data\": { \"avatarUrl\": \"\", \"createdAt\": \"2016-10-24T20:39:46\", \"curRole\": \"IdleNoRole\", \"email\": \"crifan@webonn.com\", \"errandorRating\": 0, \"facebookUserId\": \"123907074803456\", \"firstName\": \"crifan\", \"id\": \"user-4d51faba-97ff-4adf-b256-40d7c9c68103\", \"isOnline\": false, \"lastName\": \"Li\", \"location\": { \"createdAt\": null, \"fullStr\": null, \"id\": null, \"latitude\": null, \"longitude\": null, \"shortStr\": null, \"updatedAt\": null }, \"locationId\": null, \"password\": \"654321\", \"phone\": \"13511112222\", \"shareCodeCount\": 0, \"updatedAt\": \"2016-10-24T20:39:46\" }, \"message\": \"new user has created\" } ``` markdown生成文档的效果： 所以后续其他接口，均可参考上面的GET/POST等接口的写法，去写出对应的markdown的源文件，生成API文档后，效果还是不错的。 当然，也可以用其他Markdown编辑器去写md文件，去生成对应API文档。 另外，再附上，在写具体单个API接口之前的声明的部分： # 文档说明 ## 服务器API地址 前缀： ```http://115.29.173.126:21084/runningfast/api``` 完整的API地址为：```前缀```+```具体接口路径``` 比如，获取验证码都接口为： ```http://115.29.173.126:21084/runningfast/api``` + ```/v1.0/open/smscode``` -> ```http://115.29.173.126:21084/runningfast/api/v1.0/open/smscode``` ## 调用接口说明 - 如果参数格式是==JSON==的话：提交request请求时必须添加header头：==Content-Type:application/json== - 请求中是否要包含头信息：==Authorization:{accesstoken}== - 接口中==包含==```/open/```的：不需要添加 - 接口中==不包含==```/open/```：需要添加 - 说明该接口都需要对应的权限才可以访问，所以需要在请求中包含头信息：```Authorization:{accesstoken}``` - 当access token无效或者已过期时，返回： ``` { \"code\": 401, \"message\": \"invalid access token: wrong or expired\" } ``` - 所有的接口的返回形式都是统一为： - 正常返回 ``` { \"code\": 200, \"message\": \"OK\", \"data\": 某种类型的数据，比如字符串，数字，字典等等 } ``` - 错误返回 ``` { \"code\": 具体的错误码, \"message\": \"具体的错误信息字符串\" } ``` 文档效果： 优点：简单易上手 缺点：后续API更新后，需要及时更新markdown的文档内容 crifan.com，使用知识署名-相同方式共享4.0协议发布 all right reserved，powered by Gitbook该文件修订时间： 2017-12-14 14:19:25 "},"restful_doc/use_postman.html":{"url":"restful_doc/use_postman.html","title":"用Postman生成API文档","keywords":"","body":"用Postman生成API文档 步骤： Collection 鼠标移动到某个Collection 点击 三个点 Publish Docs Publish Public URL 别人打开这个Public URL即可查看API文档 效果： 详见教程：API开发利器：Postman 优点： 方便 因为本身往往已用Postman调试接口，调试完毕后，即可发布 及时更新文档 同理，在后台代码更新后，用Postman调试无误后，即可再次点击发布即可，无须手动修改API文档 美观 Postman生成的在线的API文档已足够清晰和美观 缺点： 必须依赖于在Postman中调试接口 crifan.com，使用知识署名-相同方式共享4.0协议发布 all right reserved，powered by Gitbook该文件修订时间： 2017-12-29 11:18:54 "},"restful_doc/use_swagger.html":{"url":"restful_doc/use_swagger.html","title":"用Swagger生成API文档","keywords":"","body":"用Swagger写（设计API接口的同时就可以生成出）API文档 效果： API Development Tools | Swagger Editor | Swagger 详见： 【整理】swagger OpenAPI 优点： 设计API接口的同时就是编写好了API文档 因为有对应的工具可以直接生成API文档 另外可以同时生成服务器端和客户端的代码 剩下的只需要自己编写业务逻辑即可，支持N多种编程语言 美观 生成的API文档层次够清晰，够美观 缺点： 必须用swagger去设计和编写API文档 crifan.com，使用知识署名-相同方式共享4.0协议发布 all right reserved，powered by Gitbook该文件修订时间： 2017-12-14 11:34:53 "},"restful_experience/":{"url":"restful_experience/","title":"RESTful API心得和经验","keywords":"","body":"RESTful API的心得和经验 此处把之前折腾过的RESTful的一些心得和经验整理出来，供参考。 crifan.com，使用知识署名-相同方式共享4.0协议发布 all right reserved，powered by Gitbook该文件修订时间： 2017-12-08 11:56:53 "},"restful_experience/bad_design.html":{"url":"restful_experience/bad_design.html","title":"不好的设计风格","keywords":"","body":"不好的API设计风格 所有的资源的操作类型，都用POST 听说过，有些偷懒的人，有坏习惯的人，竟然为了省事而去：把所有的资源的操作类型都用POST 而不去管，实际上应该用GET、PUT、DELETE等操作。 不论你之前是否有这个坏习惯，都不要继续再有这种坏习惯和坏做法了。 而是应该根据资源的内容和操作的目的，分别用对应的HTTP的合适的方法：GET、POST、PUT、DELETE 在接口中添加GET/UPDATE等动词 比如： GET /getUser POST /updateUser POST /cowfarm/cowfarmemp/new POST /cowfarm/cowfarmemp/update POST /cowfarm/cowfarmemp/delete/{id} 且返回值中包含了data和对应的字段 实际上不应该在接口中加这些动词，而应该通过接口的HTTP方法，GET/UPDATE，来表示接口的含义，比如改为： GET /user 获取一个用户的信息 PUT /user 更新用户的信息 POST /cowfarm/employee 表示 新建 一个农场的雇员/员工 PUT /cowfarm/employee 表示 更新 农场雇员/员工的信息 DELETE /cowfarm/employee body中包含json参数 {\"id\": xxx} 表示 删除 用户 且返回值中，message，code应该正常返回，data就没必要返回了。 非改动资源的操作却设计为POST/PUT等方法 对于没有新增/更新/删除等去改动和影响资源的操作，HTTP的方法却设计为POST/PUT等 很多公司的后台开发人员，为了偷懒省事，所有的接口都用POST，包括本应该用GET的接口 或者是，对API接口设计规范不了解，把仅仅是获取、查询资源，不会改动资源的接口设计成POST 比如，不好的做法： 通过id获取task信息：POST /task body参数：{ \"id\": \"1234\" } 查询出符合条件的任务：POST /task/query 参数放在body中 {\"keyword”:”xxx”, “start”: 0, “limit”: 10} 应该改为正常的做法： GET /task/{id} 或：GET /task?id=1234 GET /task/query?keyword=xxxx&start=0&limit=10 其中GET的query string在客户端调用API接口时，往往不是手动加上去 而是传递一个字典变量，然后用相关的encode函数去编码出来的 详见：HTTP知识总结 这样才能确保参数中包含特殊字符，服务器端也能正常接受，比如： 空格 -> %20 中文\"李茂\" -> 被UTF-8编码为 -> %e6%9d%8e%e8%8c%82 crifan.com，使用知识署名-相同方式共享4.0协议发布 all right reserved，powered by Gitbook该文件修订时间： 2018-06-19 22:40:35 "},"restful_experience/resp_data_style.html":{"url":"restful_experience/resp_data_style.html","title":"返回数据的格式和风格","keywords":"","body":"RESTful API接口返回数据的格式和风格 常见返回的数据的格式一般用JSON。 对应返回的内容，常见的做法是： code：http的status code 如果有自己定义的额外的错误，那么也可以考虑用自己定义的错误码 message：对应的文字描述信息 如果是出错，则显示具体的错误信息 否则操作成功，一般简化处理都是返回OK data 对应数据的json字符串 如果是数组，则对应最外层是[]的list 如果是对象，则对应最外层是{}的dict 比如之前某项目中设计的返回的数据格式： code是200 创建用户 POST /v1.0/open/register 返回： { \"code\": 200, \"message\": \"new user has created\", \"data\": { \"id\": \"user-4d51faba-97ff-4adf-b256-40d7c9c68103\", \"firstName\": \"crifan\", \"lastName\": \"Li\", \"password\": \"654321\", \"phone\": \"13511112222\", \"createdAt\": \"2016-10-24T20:39:46\", \"updatedAt\": \"2016-10-24T20:39:46\" ...... } } code是401 { \"code\": 401, \"message\": \"invalid access token: wrong or expired\" } crifan.com，使用知识署名-相同方式共享4.0协议发布 all right reserved，powered by Gitbook该文件修订时间： 2017-12-14 14:22:14 "},"restful_experience/experience_other.html":{"url":"restful_experience/experience_other.html","title":"其他心得","keywords":"","body":"其他RESTful API心得 调用api时要有http的前缀，否则出错Error Domain 关于其他（比如移动）端去调用REST的api时，要注意一点的是： 记得url地址写全了，最前面要加上http或https的前缀， 比如： http://115.29.173.126:21084/runningfast/api/v1.0/open/smscode 否则，如果漏了，变成： 115.29.173.126:21084/runningfast/api/v1.0/open/smscode 就会报错： FAILURE: Error Domain=NSURLErrorDomain Code=-1002 unsupported URL或URL not supported 详见：【已解决】iOS端用Alamofire访问Flask的rest的api出错：Error Domain=NSURLErrorDomain Code=-1002 api中是否一定要加版本号？ 如果是为了设计长期稳定的API接口，则最好是加上版本号v1.0这种写法 http://[hostname]/todo/api/v1.0/ 但是往往中小型项目不需要这么长期维护和不需要迭代太多版本，则可以考虑不需要版本号，则可以写成： http://[hostname]/todo/api/ 即可。 另外了解到： 有些的做法是把API的版本号v1，放到request header中。 ->github就是这么做的：Media Types | GitHub Developer Guide 设计Restful的接口时，尽量用复数，且统一 即，用/artists而不要用/artist 如果有多个对象，用模块化逻辑，嵌套资源去设计接口 举例： 获取某个（内部id为8的）歌手的所有的专辑： GET /artists/8/albums 当查询返回的数据多了则：paging分页 如上，如果一个歌手的专辑太多，则应该使用分页paging 设计分页的API时返回的数据的格式，可参考之前某项目中的返回的格式： { \"code\": 200, \"message\": \"get task/orders ok\", \"data\": { \"curPageNum\": 2, \"hasNext\": false, \"hasPrev\": true, \"numPerPage\": 10, \"tasks\": { \"task-10b01105-ec53-41bb-810e-720ab468bdf7\": {......}, \"task-da013992-e7aa-4ae9-8b6f-bdf621b9fbaa\": {......}, \"task-f3c0c660-e7f5-4583-bab2-23c7006dadc4\": {......}, \"task-f7a4d0df-3142-444b-a962-83660acd447f\": {......} }, \"totalNum\": 14, \"totalPageNum\": 2 } } 具体的解释： Pagination的对象中，最常用到的属性就是： items：具体有多少个对象，是个列表 然后就可以通过items去获取每个对象的详细信息了。 其他还有一些常用属性： page：当前的页数 pages：总的页数 per_page：每一页的个数 has_prev：是否有前一页 has_next：是否有后一页 total：（符合当前分页查询的）总（的项目的）个数 具体的Python的Flask+SQLAlchemy的API的代码，供参考： curPageTaskList = None taskPagination = None if curRole == UserRole.Initiator: taskPagination = Task.query.filter_by(initiatorId=userId).paginate( page=curPageNum, per_page=numPerPage, error_out=False) elif curRole == UserRole.Errandor: taskPagination = Task.query.filter_by(errandorId=userId).paginate( page=curPageNum, per_page=numPerPage, error_out=False) paginatedTaskList = taskPagination.items paginatedTaskDict = {} for curIdx, eachTask in enumerate(paginatedTaskList): paginatedTaskDict[eachTask.id] = marshal(eachTask, task_fields) respPaginatedTaskInfoDict = { \"curPageNum\" : taskPagination.page, \"totalPageNum\" : taskPagination.pages, \"numPerPage\" : taskPagination.per_page, \"hasPrev\" : taskPagination.has_prev, \"hasNext\" : taskPagination.has_next, \"totalTaskNum\" : taskPagination.total, 'tasks' : paginatedTaskDict } 详见：【已解决】Flask-Restful中如何设计分页的API 是否一定要严格按照Restful的规则，用对应的http的method实现对应的功能？ 一般来说，不用非常严格的依照规则，尤其是 UPDATE/PATCH 去更新修改资源 往往为了简化，用PUT表示 更新修改资源即可 不过，有些项目，对方本身就要求设计接口时，严格按照Restful的规则来设计，这时最好用UPDATE/PATCH去更新修改资源。 其他的，见上面的表格总结，典型的是： GET 获取资源 POST 新建资源 PUT 更新/修改 资源 DELETE 删除资源 POST时body中无参数时不应该添加Content-Type:application/json的Header 比如POST时,如果没有Body内容参数传递时，Header中就不要包含 Content-Type:application/json 否则，某些服务器就会返回错误。 比如Flask的Flask-Restful的接口就会自动返回： code = 0 message = Failed to decode JSON object: No JSON object could be decoded -》其意思是，你指定了 Content-Type:application/json 所以框架就会去尝试从Body中找JSON字符串，去解析参数 但是发现Body是空的，没有可用的JSON字符串待解析，所以报这个错误。 crifan.com，使用知识署名-相同方式共享4.0协议发布 all right reserved，powered by Gitbook该文件修订时间： 2018-06-19 21:49:55 "},"appendix/":{"url":"appendix/","title":"附录","keywords":"","body":"附录 下面列出相关参考资料。 crifan.com，使用知识署名-相同方式共享4.0协议发布 all right reserved，powered by Gitbook该文件修订时间： 2017-12-14 11:21:48 "},"appendix/reference.html":{"url":"appendix/reference.html","title":"参考资料","keywords":"","body":"参考资料 怎样用通俗的语言解释什么叫 REST，以及什么是 RESTful？ - 计算机网络 - 知乎 使用 Python 和 Flask 设计 RESTful API — Designing a RESTful API with Python and Flask 1.0 documentation restful update put When to use PUT or POST - The RESTful cookbook PUT Versus POST > RESTful APIs in the Real World Course 1 | KnpUniversity http - PUT vs. POST in REST - Stack Overflow HTTP Methods for RESTful Services RFC 5789 - PATCH Method for HTTP RESTful Services Quick Tips RESTful API 设计指南 - 阮一峰的网络日志 设计一个务实的RESTful API RESTful API 编写指南 API Creation - Full Stack Python REST best practices Methods When to use PUT or POST - The RESTful cookbook HTTP Methods [ RESTful APIs Verbs ] – REST API Tutorial Understanding REST What is REST? HTTP状态码 - 维基百科，自由的百科全书 List of HTTP status codes - Wikipedia Overview of RESTful API Description Languages - Wikipedia Representational state transfer - Wikipedia Stateless protocol - Wikipedia HATEOAS - Wikipedia 表现层状态转换 - 维基百科，自由的百科全书 【已解决】iOS端用Alamofire访问Flask的rest的api出错：Error Domain=NSURLErrorDomain Code=-1002 【解决】选择好的Flask的REST API的框架 Understanding HATEOAS HATEOAS - Wikipedia What is HATEOAS and why is it important? - The RESTful cookbook REST HATEOAS教程(二)：HATEOAS规范 不要被名字吓到-RESTful、HATEOAS、Spring boot之整合 - 简书 使用 Spring HATEOAS 开发 REST 服务 Why I Hate HATEOAS vertical-knowledge/ripozo: A tool for quickly creating REST/HATEOAS/Hypermedia APIs in python marshmallow-code/flask-marshmallow: Flask + marshmallow for beautiful APIs HATEOAS Driven REST APIs – REST API Tutorial pyeve/eve: REST API framework designed for human beings rest - Create request with POST, which response codes 200 or 201 and content - Stack Overflow Question about HTTP status 200 and 201 - Ruby on Rails / APIs - Code School Forum HTTP Status: 201 Created vs. 202 Accepted, by Ben Ramsey HTTP Methods for RESTful Services crifan.com，使用知识署名-相同方式共享4.0协议发布 all right reserved，powered by Gitbook该文件修订时间： 2018-06-19 22:41:58 "}}